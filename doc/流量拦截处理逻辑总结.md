# ProxyPin 流量拦截处理逻辑与 UI 交互总结

## 一、流量拦截处理逻辑架构

### 1. 核心架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        ProxyServer                              │
│  ┌─────────────┐    ┌──────────────┐    ┌─────────────────────┐│
│  │   Server    │───▶│   Channel    │───▶│ HttpProxyChannelHandler│
│  └─────────────┘    └──────────────┘    └─────────────────────┘│
│                                                │                 │
│                          ┌────────────────────┼────────────────┐│
│                          ▼                    ▼                ▼│
│                    ┌──────────┐     ┌──────────────┐  ┌────────┐│
│                    │Interceptors│    │EventListener │  │Response││
│                    └──────────┘     └──────────────┘  │Handler ││
│                                                       └────────┘│
└─────────────────────────────────────────────────────────────────┘
```

### 2. 核心类与接口

#### 2.1 `ProxyServer` - 代理服务器入口

**文件位置**: `lib/network/bin/server.dart`

```dart
/// 代理服务器
class ProxyServer {
  static ProxyServer? current;
  Server? server;                        // socket服务
  List<EventListener> listeners = [];    // 请求事件监听
  final Configuration configuration;     // 配置

  // 核心方法
  Future<Server> start();               // 启动代理服务
  Future<Server?> stop();               // 停止代理服务
  void addListener(EventListener);      // 添加监听器
}
```

#### 2.2 `EventListener` - 事件监听接口（核心交互接口）

**文件位置**: `lib/network/bin/listener.dart`

```dart
/// 请求和响应事件监听
abstract class EventListener {
  void onRequest(Channel channel, HttpRequest request);           // 请求事件
  void onResponse(ChannelContext channelContext, HttpResponse response);  // 响应事件
  void onMessage(Channel channel, HttpMessage message, WebSocketFrame frame);  // WebSocket消息
}
```

#### 2.3 `Interceptor` - 拦截器接口

**文件位置**: `lib/network/components/interceptor.dart`

```dart
abstract class Interceptor {
  int get priority => 0;                                    // 拦截器优先级

  Future<HostAndPort> preConnect(HostAndPort hostAndPort);  // 连接前处理
  Future<HttpResponse?> execute(HttpRequest request);       // 执行拦截（可直接返回响应）
  Future<HttpRequest?> onRequest(HttpRequest request);      // 请求拦截（返回null则阻止请求）
  Future<HttpResponse?> onResponse(HttpRequest, HttpResponse);  // 响应拦截
  Future<void> onError(HttpRequest?, error, StackTrace?);   // 错误处理
}
```

#### 2.4 `ChannelHandler` - 通道处理器

**文件位置**: `lib/network/channel/channel.dart`

```dart
abstract class ChannelHandler<T> {
  void channelActive(ChannelContext context, Channel channel);     // 连接建立
  Future<void> channelRead(ChannelContext, Channel, T msg);        // 读取数据
  void channelInactive(ChannelContext, Channel);                   // 连接断开
  void exceptionCaught(ChannelContext, Channel, error, {StackTrace?});  // 异常处理
}
```

#### 2.5 `Channel` - 网络通道

**文件位置**: `lib/network/channel/channel.dart`

```dart
class Channel {
  final ChannelDispatcher dispatcher;
  Socket _socket;
  bool isOpen = true;
  final InetSocketAddress remoteSocketAddress;

  String get id;                          // 全局唯一标识符
  bool get isSsl;                         // 是否SSL连接
  bool get isClosed;                      // 是否已关闭

  Future<void> write(ChannelContext, Object);      // 写入数据
  Future<void> writeBytes(List<int>);              // 写入字节
  Future<void> writeAndClose(ChannelContext, Object);  // 写入并关闭
  void close();                                    // 关闭通道
  Future<SecureSocket> secureSocket(...);          // SSL握手
}
```

#### 2.6 `ChannelContext` - 通道上下文

**文件位置**: `lib/network/channel/channel_context.dart`

```dart
class ChannelContext {
  Channel? clientChannel;     // 和本地客户端的连接
  Channel? serverChannel;     // 和远程服务端的连接
  EventListener? listener;

  HostAndPort? get host;              // 目标主机
  HttpRequest? get currentRequest;    // 当前请求
  ProcessInfo? get processInfo;       // 进程信息

  T? getAttribute<T>(String key);     // 获取属性
  void putAttribute(String key, Object? value);  // 设置属性

  Future<Channel> connectServerChannel(HostAndPort, ChannelHandler);  // 创建服务端连接
}
```

---

### 3. 内置拦截器

| 拦截器 | 优先级 | 文件位置 | 功能 |
|--------|--------|----------|------|
| `Hosts` | 默认 | `lib/network/components/hosts.dart` | 域名解析/映射 |
| `RequestMapInterceptor` | 默认 | `lib/network/components/request_map.dart` | 请求映射 |
| `RequestRewriteInterceptor` | 默认 | `lib/network/components/request_rewrite.dart` | 请求/响应重写 |
| `ScriptInterceptor` | 10 | `lib/network/components/script.dart` | JS脚本处理 |
| `RequestBlockInterceptor` | 1000 | `lib/network/components/request_block.dart` | 请求/响应屏蔽 |
| `ReportServerInterceptor` | 默认 | `lib/network/components/report_server_interceptor.dart` | 上报服务 |

---

### 4. 请求处理流程

```
客户端请求
    │
    ▼
┌──────────────────────────────────────────────────────┐
│            HttpProxyChannelHandler.channelRead()      │
│  1. 检查是否下载证书请求                              │
│  2. 检查是否本地请求                                  │
│  3. 调用 forward() 转发                              │
└──────────────────────────────────────────────────────┘
    │
    ▼
┌──────────────────────────────────────────────────────┐
│                   forward() 转发流程                  │
│  1. 获取远程连接 _getRemoteChannel()                 │
│  2. 检查域名过滤 HostFilter.filter()                 │
│  3. 遍历拦截器 interceptor.onRequest()               │
│  4. 通知监听器 listener.onRequest()                  │
│  5. 检查拦截器是否直接返回响应 interceptor.execute() │
│  6. 检查重定向规则                                    │
│  7. 发送请求到远程服务器                              │
└──────────────────────────────────────────────────────┘
    │
    ▼
┌──────────────────────────────────────────────────────┐
│         HttpResponseProxyHandler.channelRead()       │
│  1. 遍历拦截器 interceptor.onResponse()              │
│  2. 通知监听器 listener.onResponse()                 │
│  3. 转发响应给客户端                                  │
└──────────────────────────────────────────────────────┘
```

---

## 二、UI 层交互逻辑

### 1. 交互架构

```
┌─────────────────────────────────────────────────────────────────┐
│                          UI Layer                                │
│  ┌──────────────────┐         ┌──────────────────────────────┐ │
│  │DesktopHomePage   │         │ MobileHomePage               │ │
│  │implements        │         │ implements                   │ │
│  │EventListener     │         │ EventListener                │ │
│  └────────┬─────────┘         └──────────────┬───────────────┘ │
│           │                                   │                 │
│           └───────────┬───────────────────────┘                 │
│                       ▼                                         │
│              ┌────────────────┐                                 │
│              │ ProxyServer    │                                 │
│              │ .addListener() │                                 │
│              └────────────────┘                                 │
│                       │                                         │
│                       ▼                                         │
│    ┌─────────────────────────────────────────────────────────┐ │
│    │              RequestListWidget                           │ │
│    │   ┌─────────────┐    ┌─────────────┐   ┌─────────────┐  │ │
│    │   │ DomainList  │    │ Sequence    │   │ Panel       │  │ │
│    │   └─────────────┘    └─────────────┘   └─────────────┘  │ │
│    └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

### 2. UI 层核心实现

#### 2.1 桌面端 `DesktopHomePage`

**文件位置**: `lib/ui/desktop/desktop.dart`

```dart
class _DesktopHomePagePageState extends State<DesktopHomePage> implements EventListener {
  static final container = ListenableList<HttpRequest>();

  // 实现 EventListener 接口
  @override
  void onRequest(Channel channel, HttpRequest request) {
    requestListStateKey.currentState!.add(channel, request);
    // 内存监控清理
    MemoryCleanupMonitor.onMonitor(onCleanup: () {
      requestListStateKey.currentState?.cleanupEarlyData(32);
    });
  }

  @override
  void onResponse(ChannelContext channelContext, HttpResponse response) {
    requestListStateKey.currentState!.addResponse(channelContext, response);
  }

  @override
  void onMessage(Channel channel, HttpMessage message, WebSocketFrame frame) {
    if (panel.request.get() == message || panel.response.get() == message) {
      panel.changeState();  // 更新面板状态
    }
  }

  @override
  void initState() {
    proxyServer.addListener(this);  // 注册监听器
  }
}
```

#### 2.2 移动端 `MobileHomePage`

**文件位置**: `lib/ui/mobile/mobile.dart`

```dart
class MobileHomeState extends State<MobileHomePage> implements EventListener, LifecycleListener {
  // 实现 EventListener 接口
  @override
  void onRequest(Channel channel, HttpRequest request) {
    MobileApp.requestStateKey.currentState!.add(channel, request);
    PictureInPicture.addData(request.requestUrl);  // 画中画显示
    // 内存监控
    MemoryCleanupMonitor.onMonitor(onCleanup: () {
      MobileApp.requestStateKey.currentState?.cleanupEarlyData(32);
    });
  }

  @override
  void onResponse(ChannelContext channelContext, HttpResponse response) {
    MobileApp.requestStateKey.currentState!.addResponse(channelContext, response);
  }

  @override
  void initState() {
    proxyServer = ProxyServer(widget.configuration);
    proxyServer.addListener(this);  // 注册监听器
    proxyServer.start();            // 启动代理
  }
}
```

### 3. 请求列表管理

#### `DesktopRequestListState` 核心方法

**文件位置**: `lib/ui/desktop/request/list.dart`

| 方法 | 功能 |
|------|------|
| `add(Channel, HttpRequest)` | 添加新请求到列表 |
| `addResponse(ChannelContext, HttpResponse)` | 更新请求对应的响应 |
| `cleanupEarlyData(int)` | 清理早期数据（内存管理） |
| `search(SearchModel)` | 搜索过滤请求 |
| `export(String)` | 导出为 HAR 文件 |
| `repeatAllRequests()` | 重放所有请求 |

---

## 三、数据模型

### `HttpMessage` - HTTP消息基类

**文件位置**: `lib/network/http/http.dart`

```dart
abstract class HttpMessage {
  String protocolVersion;
  final HttpHeaders headers;
  List<int>? body;
  String requestId;
  int? streamId;

  bool get isWebSocket;
  ContentType get contentType;
  String get bodyAsString;
  List<String> get cookies;
  List<WebSocketFrame> messages;
}
```

### `HttpRequest` - HTTP请求模型

**文件位置**: `lib/network/http/http.dart`

```dart
class HttpRequest extends HttpMessage {
  String _uri;
  HttpMethod method;
  HostAndPort? hostAndPort;
  DateTime requestTime;
  HttpResponse? response;
  Map<String, dynamic> attributes;
  ProcessInfo? processInfo;

  // 核心属性
  String get requestUrl;       // 完整请求URL
  String get domainPath;       // 域名+路径
  String get path;             // 请求路径
  String get pathAndQuery;     // 路径+查询参数
  Map<String, String> queries; // 查询参数

  // 方法
  HttpRequest copy({String? uri});  // 复制请求

  // 序列化
  Map<String, dynamic> toJson();
  factory HttpRequest.fromJson(Map<String, dynamic>);
}
```

### `HttpResponse` - HTTP响应模型

**文件位置**: `lib/network/http/http.dart`

```dart
class HttpResponse extends HttpMessage {
  HttpStatus status;
  DateTime responseTime;
  HttpRequest? request;

  String costTime();  // 计算响应耗时

  // 序列化
  Map<String, dynamic> toJson();
  factory HttpResponse.fromJson(Map<String, dynamic>);
}
```

### `HttpMethod` - HTTP方法枚举

```dart
enum HttpMethod {
  get("GET"),
  post("POST"),
  put("PUT"),
  patch("PATCH"),
  delete("DELETE"),
  options("OPTIONS"),
  head("HEAD"),
  trace("TRACE"),
  connect("CONNECT"),
  propfind("PROPFIND"),
  report("REPORT");

  static HttpMethod valueOf(String name);
  static List<HttpMethod> methods();
}
```

### `HttpStatus` - HTTP状态码

```dart
class HttpStatus {
  static final HttpStatus ok = newStatus(200, "OK");
  static final HttpStatus badRequest = newStatus(400, "Bad Request");
  static final HttpStatus unauthorized = newStatus(401, "Unauthorized");
  static final HttpStatus forbidden = newStatus(403, "Forbidden");
  static final HttpStatus notFound = newStatus(404, "Not Found");
  static final HttpStatus internalServerError = newStatus(500, "Internal Server Error");
  // ...

  final int code;
  String reasonPhrase;

  bool isSuccessful();  // 是否成功 (200-299)
}
```

---

## 四、关键接口方法总结表

| 层级 | 接口/类 | 方法 | 说明 |
|------|---------|------|------|
| **网络层** | `ProxyServer` | `start()` | 启动代理服务 |
| | | `stop()` | 停止代理服务 |
| | | `addListener(EventListener)` | 添加事件监听器 |
| | | `restart()` | 重启代理服务 |
| | | `retryBind()` | 检查并重新绑定端口 |
| | `EventListener` | `onRequest(Channel, HttpRequest)` | 请求事件回调 |
| | | `onResponse(ChannelContext, HttpResponse)` | 响应事件回调 |
| | | `onMessage(Channel, HttpMessage, WebSocketFrame)` | WebSocket消息回调 |
| | `Interceptor` | `onRequest(HttpRequest)` | 请求拦截 |
| | | `onResponse(HttpRequest, HttpResponse)` | 响应拦截 |
| | | `execute(HttpRequest)` | 直接返回响应 |
| | | `preConnect(HostAndPort)` | 连接前处理 |
| | | `onError(HttpRequest?, error, StackTrace?)` | 错误处理 |
| | `ChannelHandler` | `channelActive(ChannelContext, Channel)` | 连接建立 |
| | | `channelRead(ChannelContext, Channel, T)` | 读取数据 |
| | | `channelInactive(ChannelContext, Channel)` | 连接断开 |
| | | `exceptionCaught(...)` | 异常处理 |
| | `Channel` | `write(ChannelContext, Object)` | 写入数据 |
| | | `writeAndClose(ChannelContext, Object)` | 写入并关闭 |
| | | `close()` | 关闭通道 |
| | | `secureSocket(...)` | SSL握手 |
| **UI层** | `RequestListState` | `add(Channel, HttpRequest)` | 添加请求 |
| | | `addResponse(ChannelContext, HttpResponse)` | 添加响应 |
| | | `cleanupEarlyData(int)` | 清理数据 |
| | | `search(SearchModel)` | 搜索请求 |
| | | `export(String)` | 导出HAR |
| | `NetworkTabController` | `changeState()` | 刷新面板 |

---

## 五、设计模式总结

1. **观察者模式 (Observer Pattern)**
   - `EventListener` 接口实现网络层与 UI 层的解耦
   - `ProxyServer.addListener()` 注册观察者
   - 网络事件发生时通知所有监听器

2. **责任链模式 (Chain of Responsibility)**
   - `Interceptor` 拦截器链实现可扩展的请求/响应处理
   - 按优先级排序执行
   - 任意拦截器可中断请求链

3. **单例模式 (Singleton)**
   - `ProxyServer.current` 全局单例
   - 各 Manager 类使用单例（如 `RequestRewriteManager.instance`）

4. **策略模式 (Strategy)**
   - 不同类型的 `ChannelHandler` 处理不同协议
   - `HttpProxyChannelHandler` 处理 HTTP
   - `HttpResponseProxyHandler` 处理响应

---

## 六、文件目录结构

```
lib/network/
├── bin/
│   ├── configuration.dart    # 配置管理
│   ├── listener.dart         # EventListener 接口定义
│   └── server.dart           # ProxyServer 代理服务器
├── channel/
│   ├── channel.dart          # Channel 和 ChannelHandler
│   ├── channel_context.dart  # ChannelContext 上下文
│   ├── channel_dispatcher.dart
│   ├── host_port.dart        # HostAndPort 主机端口
│   └── network.dart          # 网络连接
├── components/
│   ├── interceptor.dart      # Interceptor 拦截器接口
│   ├── host_filter.dart      # 域名过滤
│   ├── hosts.dart            # Hosts 映射
│   ├── request_block.dart    # 请求屏蔽
│   ├── request_map.dart      # 请求映射
│   ├── request_rewrite.dart  # 请求重写
│   ├── script.dart           # 脚本拦截器
│   └── manager/              # 各功能管理器
├── handle/
│   ├── http_proxy_handle.dart   # HTTP代理处理器
│   ├── relay_handle.dart        # 中继处理器
│   ├── sse_handle.dart          # SSE处理器
│   └── websocket_handle.dart    # WebSocket处理器
├── http/
│   ├── http.dart             # HttpRequest/HttpResponse 模型
│   ├── http_headers.dart     # HTTP头部
│   ├── http_client.dart      # HTTP客户端
│   ├── codec.dart            # 编解码器
│   └── ...
└── util/                     # 工具类
```

